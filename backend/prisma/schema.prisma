generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

model User {
  id           Int      @id @default(autoincrement())
  email        String   @unique
  passwordHash String
  displayName  String
  createdAt    DateTime @default(now())

  // Profile fields
  avatar       String?  @db.VarChar(500)
  banner       String?  @db.VarChar(500)
  bio          String?  @db.VarChar(500)
  location     String?  @db.VarChar(100)
  website      String?  @db.VarChar(200)
  dateOfBirth  DateTime?

  posts         Post[]
  following     Follow[]       @relation("Following")
  followers     Follow[]       @relation("Followers")
  userInterests UserInterest[]
  likes         Like[]
  comments      Comment[]
  friendRequestsSent     FriendRequest[] @relation("FR_From")
  friendRequestsReceived FriendRequest[] @relation("FR_To")

  notificationsReceived Notification[] @relation("NotifTo")
  notificationsSent     Notification[] @relation("NotifFrom")

  groupInvitesReceived GroupInvite[] @relation("GroupInviteTo")
  groupInvitesSent     GroupInvite[] @relation("GroupInviteFrom")

  friendshipsAsA Friendship[] @relation("FS_A")
  friendshipsAsB Friendship[] @relation("FS_B")

  groupsOwned   Group[]
  groupMembers  GroupMember[]
  eventsCreated Event[]
  eventAttendances EventAttendee[]

  conversationMembers ConversationMember[]
  messagesSent Message[]

  blockedBy UserBlock[] @relation("BlockedBy")
  blocking UserBlock[] @relation("Blocking")
  
  mutedBy UserMute[] @relation("MutedBy")
  muting UserMute[] @relation("Muting")

  privacy UserPrivacy?
}

model Follow {
  followerId Int
  followedId Int
  createdAt  DateTime @default(now())

  follower User @relation("Following", fields: [followerId], references: [id], onDelete: Cascade)
  followed User @relation("Followers", fields: [followedId], references: [id], onDelete: Cascade)

  @@id([followerId, followedId])
  @@index([followedId])
}

enum PostVisibility {
  PUBLIC
  FOLLOWERS
  FRIENDS
  PRIVATE
}

model Post {
  id        Int      @id @default(autoincrement())
  content   String   @db.Text
  createdAt DateTime @default(now())

  visibility PostVisibility @default(PUBLIC)

  comments    Comment[]

  authorId Int
  author   User @relation(fields: [authorId], references: [id], onDelete: Cascade)

  likes Like[]

  notifications Notification[]

  groupId Int?
  group   Group? @relation("GroupPosts", fields: [groupId], references: [id], onDelete: Cascade)

  @@index([groupId, createdAt])
}

model Like {
  userId    Int
  postId    Int
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  post Post @relation(fields: [postId], references: [id], onDelete: Cascade)

  @@id([userId, postId])
  @@index([postId])
}

model Interest {
  id   Int    @id @default(autoincrement())
  name String @unique

  users UserInterest[]
}

model UserInterest {
  userId     Int
  interestId Int

  user     User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  interest Interest @relation(fields: [interestId], references: [id], onDelete: Cascade)

  @@id([userId, interestId])
  @@index([interestId])
}

model FriendRequest {
  id         Int      @id @default(autoincrement())
  fromUserId Int
  toUserId   Int
  status     String   @default("PENDING") // PENDING | ACCEPTED | REJECTED
  createdAt  DateTime @default(now())

  fromUser User @relation("FR_From", fields: [fromUserId], references: [id], onDelete: Cascade)
  toUser   User @relation("FR_To", fields: [toUserId], references: [id], onDelete: Cascade)

  notifications Notification[]

  @@unique([fromUserId, toUserId])
  @@index([toUserId, status])
}

model Friendship {
  userAId   Int
  userBId   Int
  createdAt DateTime @default(now())

  userA User @relation("FS_A", fields: [userAId], references: [id], onDelete: Cascade)
  userB User @relation("FS_B", fields: [userBId], references: [id], onDelete: Cascade)
  
  @@id([userAId, userBId])
  @@index([userBId])
}

model Comment {
  id        Int      @id @default(autoincrement())
  content   String   @db.VarChar(1000)

  postId    Int
  userId    Int

  post      Post     @relation(fields: [postId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  notifications Notification[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([postId, createdAt])
  @@index([userId, createdAt])
}

enum NotificationType {
  LIKE
  COMMENT
  FRIEND_REQUEST
  FRIEND_ACCEPTED
  FOLLOW
  GROUP_INVITE
  GROUP_JOIN
  EVENT_CREATED
  EVENT_RSVP
}


model Notification {
  id        Int              @id @default(autoincrement())
  type      NotificationType

  toUserId   Int
  fromUserId Int?

  postId     Int?
  commentId  Int?
  friendRequestId Int?

  createdAt DateTime @default(now())
  readAt    DateTime?

  toUser   User   @relation("NotifTo", fields: [toUserId], references: [id], onDelete: Cascade)
  fromUser User?  @relation("NotifFrom", fields: [fromUserId], references: [id], onDelete: SetNull)

  post     Post?    @relation(fields: [postId], references: [id], onDelete: Cascade)
  comment  Comment? @relation(fields: [commentId], references: [id], onDelete: Cascade)
  friendRequest FriendRequest? @relation(fields: [friendRequestId], references: [id], onDelete: Cascade)
  eventId Int?
  event   Event? @relation(fields: [eventId], references: [id], onDelete: Cascade)

  @@index([toUserId, createdAt])
  @@index([toUserId, readAt])
}

enum GroupPrivacy {
  PUBLIC
  PRIVATE
  SECRET
}

enum EventRSVP {
  GOING
  DECLINED
}
 
model Group {
  id          Int      @id @default(autoincrement())
  name        String
  description String?  @db.VarChar(500)
  createdAt   DateTime @default(now())

  privacy     GroupPrivacy @default(PUBLIC)

  ownerId Int
  owner   User @relation(fields: [ownerId], references: [id], onDelete: Cascade)

  members GroupMember[]
  posts   Post[] @relation("GroupPosts")
  events  Event[]

  invites GroupInvite[]
  inviteLinks GroupInviteLink[]
  conversations Conversation[]

  @@index([ownerId, createdAt])
}



model GroupMember {
  groupId  Int
  userId   Int
  role     String   @default("MEMBER") // OWNER | ADMIN | MEMBER
  joinedAt DateTime @default(now())

  group Group @relation(fields: [groupId], references: [id], onDelete: Cascade)
  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([groupId, userId])
  @@index([userId, joinedAt])
}

model Event {
  id          Int      @id @default(autoincrement())
  title       String   @db.VarChar(191)
  description String?  @db.VarChar(1000)
  location    String?  @db.VarChar(191)
  startAt     DateTime
  endAt       DateTime?
  createdAt   DateTime @default(now())

  groupId Int
  group   Group @relation(fields: [groupId], references: [id], onDelete: Cascade)

  creatorId Int
  creator   User @relation(fields: [creatorId], references: [id], onDelete: Cascade)

  attendees EventAttendee[]

  notifications Notification[]

  @@index([groupId, startAt])
  @@index([creatorId, createdAt])
}

model EventAttendee {
  eventId Int
  userId  Int
  status  EventRSVP @default(GOING)
  joinedAt DateTime @default(now())

  event Event @relation(fields: [eventId], references: [id], onDelete: Cascade)
  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([eventId, userId])
  @@index([userId, joinedAt])
}

model GroupInvite {
  id        Int      @id @default(autoincrement())
  groupId   Int
  fromUserId Int
  toUserId  Int
  createdAt DateTime @default(now())

  group Group @relation(fields: [groupId], references: [id], onDelete: Cascade)
  fromUser User @relation("GroupInviteFrom", fields: [fromUserId], references: [id], onDelete: Cascade)
  toUser   User @relation("GroupInviteTo", fields: [toUserId], references: [id], onDelete: Cascade)

  @@unique([groupId, toUserId])
}

model GroupInviteLink {
  id        Int      @id @default(autoincrement())
  token     String   @unique
  groupId   Int
  createdAt DateTime @default(now())
  expiresAt DateTime?

  group Group @relation(fields: [groupId], references: [id], onDelete: Cascade)

  @@index([groupId])
}

model Conversation {
  id        Int      @id @default(autoincrement())
  groupId   Int?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  group   Group? @relation(fields: [groupId], references: [id], onDelete: Cascade)
  members ConversationMember[]
  messages Message[]

  @@index([groupId])
}

model ConversationMember {
  conversationId Int
  userId         Int
  joinedAt       DateTime @default(now())
  lastReadAt     DateTime?

  conversation Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  user         User         @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([conversationId, userId])
  @@index([userId])
}

model Message {
  id             Int      @id @default(autoincrement())
  content        String   @db.Text
  conversationId Int
  senderId       Int
  createdAt      DateTime @default(now())

  conversation Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  sender       User         @relation(fields: [senderId], references: [id], onDelete: Cascade)

  @@index([conversationId, createdAt])
  @@index([senderId])
}

enum ProfileVisibility {
  PUBLIC
  FOLLOWERS
  PRIVATE
}

model UserBlock {
  blockerId Int
  blockedId Int
  createdAt DateTime @default(now())

  blocker User @relation("BlockedBy", fields: [blockerId], references: [id], onDelete: Cascade)
  blocked User @relation("Blocking", fields: [blockedId], references: [id], onDelete: Cascade)

  @@id([blockerId, blockedId])
  @@index([blockedId])
}

model UserMute {
  muterId Int
  mutedId Int
  createdAt DateTime @default(now())

  muter User @relation("MutedBy", fields: [muterId], references: [id], onDelete: Cascade)
  muted User @relation("Muting", fields: [mutedId], references: [id], onDelete: Cascade)

  @@id([muterId, mutedId])
  @@index([mutedId])
}

model UserPrivacy {
  userId              Int      @id
  profileVisibility   ProfileVisibility @default(PUBLIC)
  canReceiveMessages  Boolean  @default(true)
  updatedAt           DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}
